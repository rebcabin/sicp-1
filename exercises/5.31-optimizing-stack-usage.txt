In evaluating a procedure application, the explicit-control evaluator always
    (1) saves and restores the env register around the evaluation of the operator, 
    (2) saves and restores env around the evaluation of each operand (except the final one [or zero-operand case]), 
    (3) saves and restores argl around the evaluation of each operand [including final one, but not zero-operand case], and 
    (4) saves and restores proc around the evaluation of the operand sequence [but not in zero-operand case].


Annotated from ch5-eceval.scm:

ev-application                                                
  (save continue)                                             
  (save env)                                            ; (1) push                                  
  (assign unev (op operands) (reg expr))                      
  (save unev)                                                 
  (assign expr (op operator) (reg expr))
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))                                
ev-appl-did-operator                                          
  (restore unev)                                              
  (restore env)                                         ; (1) pop                                  
  (assign argl (op empty-arglist))                            
  (assign proc (reg val))                                     
  (test (op no-operands?) (reg unev))                         
  (branch (label apply-dispatch))                             
  (save proc)                                           ; (4) push     
ev-appl-operand-loop                                          
  (save argl)                                           ; (3) push 
  (assign expr (op first-operand) (reg unev))                 
  (test (op last-operand?) (reg unev))                        
  (branch (label ev-appl-last-arg))                           
  (save env)                                            ; (2) push
  (save unev)                                                 
  (assign continue (label ev-appl-accumulate-arg))
  (goto (label eval-dispatch))                                
ev-appl-accumulate-arg                                        
  (restore unev)
  (restore env)                                         ; (2) pop                           
  (restore argl)                                        ; (3) pop, for non-final operand
  (assign argl (op adjoin-arg) (reg val) (reg argl))          
  (assign unev (op rest-operands) (reg unev))                 
  (goto (label ev-appl-operand-loop))                         
ev-appl-last-arg                                              
  (assign continue (label ev-appl-accum-last-arg))            
  (goto (label eval-dispatch))                                
ev-appl-accum-last-arg                                        
  (restore argl)                                        ; (3) pop, for final operand
  (assign argl (op adjoin-arg) (reg val) (reg argl))          
  (restore proc)                                        ; (4) pop
  (goto (label apply-dispatch))                               
apply-dispatch                                                
  (test (op primitive-procedure?) (reg proc))                 
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (goto (label unknown-procedure-type))
  
  
a. (f 'x 'y)
    operator = variable 
    argument = quotes
    
b. ((f) 'x 'y)
    operator = application with NO ARGUMENTS
    argument = quotes
    
c. (f (g 'x) y)
    operator = variable
    argument = application(quote) + variable
    
d. (f (g 'x) 'y)
    operator = variable
    argument = application(quote) + quote
    
So the question becomes: do the following evaluators trash env, argl, or proc?
    ev-variable
    ev-quoted
    ev-application (no args)
    ev-application (1 arg)
    
    
ev-variable                                                    
  (assign val (op lookup-variable-value) (reg expr) (reg env))    
  (goto (reg continue))
    ; since lookup-variable-value is a "primitive", ONLY register val gets trashed.
    
ev-quoted
  (assign val (op text-of-quotation) (reg expr))
  (goto (reg continue))
    ; since text-of-quotation is a "primitive", ONLY register val gets trashed.
    
-----------------------------    
Answer to a: ALL save/restore pairs are superfluous and can be eliminated.
-----------------------------


(f) and (g 'x)
- well, couldn't these possibly have nested calls?? 
- who KNOWS what those nested calls do!
- i'm gonna say 
-----------------------------    
Answer to b-d: NONE of the save/restore pairs are superfluous
-----------------------------
